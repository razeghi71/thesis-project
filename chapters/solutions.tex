\فصل{بیان راه‌حل‌های پیشنهادی برای مشکلات ذکر شده}

در این فصل نرم‌افزار مدیریت رمز عبور طراحی شده را همراه با نحوه‌ی حل مشکلات ذکر شده تشریح می‌کنیم.

\قسمت{مشکل وصل شدن \لر{Keylogger} به \لر{X Server}}

برای رفع این مشکل باید هنگام گرفتن گذرواژه از کاربر کنترل صفحه کلید را از \لر{X Server} خارج کنیم. برای کار باید از قابلیت‌های ذکر شده در \ارجاع{لینوکس:انتزاع} و \ارجاع{لینوکس:انحصار}  استفاده کنیم. یعنی به صورت مستقیم به دستگاه صفحه کلید واقع در \لر{/dev} وصل شده و آن را \لر{grab} کنیم. لذا دیگر \لر{X Server} قابلیت خواندن کلید‌های صفحه کلید را نداشته و نمی‌تواند آن‌ها را برنامه‌ی دیگری بدهد.

\قسمت{مشکل اجرای برنامه‌ی مشابه}

برای اینکه این مشکل رفع شود، هنگام نصب نرم‌افزار کلمه‌ای را از کاربر میگیریم و ذخیره می‌کنیم. از این پس هر دفعه هنگام پرسیدن گذرواژه‌ی اصلی آن را به کاربر نشان می‌دهیم تا کاربر مطمئن شود که برنامه‌ای که اجرا شده است همان برنامه‌ی اصلی‌است.

با توجه به اینکه این کلمه باید به صورت خام ذخیره شود. پس کاربر عادی نباید به جایی که این کلمه در آن ذخیره شده است دسترسی داشته باشد. در اینجا فرض میکنیم این کلمه در فایلی ذخیره شده است. 

برای رفع کردن این مشکل گروهی مانند \لر{passmanager} درست میکنیم و صاحب\پانویس{owner} فایل حاوی کلمه را به \لر{root} و گروه آن را به \لر{passmanager} تغییر می‌دهیم. از طرفی مجوز فایل را  \لر{770} می‌کنیم، به این معنی که فقط صاحب فایل که \لر{root} است و کسانی که عضو گروه \لر{passmanager} هستند قابلیت خواندن و نوشتن در این فایل را دارند. 

حال می‌توانیم گروه موثر برنامه‌ی اصلی را به \لر{passmanager} تغییر دهیم تا بتواند به فایل حاوی کلمه‌ی مورد نظر دسترسی داشته باشد و آن را به کاربر نشان دهد. ولی با توجه به اینکه این کلمه بسیار موردِ مهمی است. بهتر است تا یک برنامه‌ی بسیار کوچک که فقط وظیفه‌اش این است که این فایل را بخواند به آن دسترسی داشته باشد. و محتوی لازم را از طریق سوکت دامنه‌ی یونیکس به برنامه‌ی اصلی برای نشان دادن منتقل کند. نام این برنامه را \لر{PasswordChecker} میگذاریم.

مشکلی که اکنون به وجود می‌آید این است که برنامه‌ی \لر{Keylogger} می‌تواند جای برنامه‌ی اصلی بنشیند و کلمه را از این برنامه‌ی کوچک روی سوکت دامنه‌ی یونیکس بگیرد.
برای رفع این مشکل با توجه به \ارجاع{لینوکس:سوکت} از قابلیت ارسال \لر{Credential} پردازه در سوکت دامنه‌ی یونیکس استفاده میکنیم. به این صورت که \لر{PasswordChecker} هر بار که برنامه‌ی اصلی به آن وصل می‌شود با استفاده از شماره پردازه و شبه‌فایل‌سیستم \لر{proc} مسیر فایل اجرایی برنامه‌ی اصلی را به دست آورده و \لر{Hash} آن را محاسبه می‌کند و در صورت معتبر بودن آن اجازه‌ی اتصال را می‌دهد. علاوه بر این برنامه‌ی \لر{PasswordChecker} چک می‌کند که فایل اجرایی برنامه‌ی اصلی توسط کاربر عادی مجوز نوشته شدن نداشته باشد تا \لر{Keylogger} نتواند پس از اجرای آن جایگزین شود.

به نظر مشکل وصل شدن \لر{Keylogger} به \لر{X Server} حل شد. اما \لر{X Server} نه تنها کلید‌های فشرده شده بلکه تصویر صفحه را نیز در اختیار برنامه‌ها می‌گذارد. یک نرم‌افزار می‌تواند با وصل شدن به \لر{X Server} تصویر صفحه‌ی فعلی را دریافت کند (این همان کاری است که نرم افزارهای \لر{ScreenShot} انجام می‌دهند). حال کافی است یک بار نرم‌افزار اصلی مدیریت گذرواژه اجرا شود، \لر{Keylogger} تصویری از صفحه گرفته و سپس با یک پردازش تصویر ساده، کلمه‌ی انتخاب شده توسط کاربر را پیدا کند.

برای رفع این مشکل نیازمند یک محیط هستیم که تحت نظر \لر{X Server} نباشد. \لر{XServer} فقط به آن \لر{tty}ی که در آن اجرا شده است دسترسی دارد. پس کافی است تا برنامه‌ی گرفتن رمز عبور اصلی را از برنامه‌ی اصلی جدا کنیم و آن را همانطور که در \ارجاع{لینوکس:تی‌تی‌وای} گفتیم با استفاده از \لر{openvt} در یک \لر{tty} دیگر اجرا کنیم. 

برنامه‌ی جدا شده را \لر{PasswordGetter} می‌نامیم. این برنامه باید با گروه موثر \لر{input} اجرا شود برای اینکار همانطور که در \ارجاع{لینوکس:مجوز} گفته شد، ابتدا گروه فایل را \لر{input} می‌کنیم و سپس پرچم \لر{sgid} را بر روی آن روشن می‌کنیم.

طرز کار برنامه‌ی \لر{PasswordGetter} به این صورت است که ابتدا روی یک سوکت دامنه یونیکس با برنامه‌ی اصلی از نرم‌افزار \لر{PasswordChecker} کلمه‌ی انتخابی کاربر را گرفته و به کاربر نشان می‌دهد تا عملیات احراز اصالت برنامه صورت بگیرد. سپس از کاربر درخواست می‌کند که گذرواژه‌ی اصلی را وارد کند. پس از گرفتن گذرواژه از کاربر، \لر{Hash} آن را محاسبه کرده و با مقدار ذخیره شده روی دیسک مقایسه میکند در صورتی که این مقدار صحیح بود این برنامه روی یک سوکت دامنه‌ی یونیکس این گذرواژه را برای برنامه‌ی اصلی ارسال می‌کند و در صورت غلط بودن دوباره شروع به پرسیدن گذرواژه از کاربر میکند. برای اینکه به کاربر این امکان را بدهیم که در صورت علاقه بتواند این عملیات را لغو کند، یک عدد تصادفی نیز تولید کرده و به کاربر نشان می‌دهیم که در صورتی که کاربر آن مقدار را وارد کرد \لر{PasswordGetter} به اطلاع برنامه‌ی اصلی می‌رساند که کاربر گذرواژه را وارد نکرد و برنامه‌ی اصلی نیز بسته می‌شود.

لازم به ذکر است که تنها دسترسی که برنامه‌ی مهاجمی که با استفاده از کاربری به جز \لر{root} اجرا شده به \لر{tty} برنامه‌ی \لر{PasswordGetter} دارد دسترسی نوشتن در آن است. یعنی می‌تواند جای کلمه‌ای که کاربر برای احراز اصالت برنامه نوشته بود یا جای عدد تصادفی که تولید کردیم چیز دیگری بنویسد که با توجه به اینکه این برنامه‌ها قصد ناشناخته بودن دارند انجام این کار برایشان باعث لو رفتن آنها می‌شود.

مشکلی که اکنون به وجود می‌آید این است که برنامه‌ی \لر{Keylogger} می‌تواند جای برنامه‌ی \لر{PasswordGetter} بنشیند و گذرواژه را از کاربر گرفته و به برنامه‌ی اصلی ارسال کند. 

برای رفع این مشکل از راهکار مشابه بالا که برای برنامه‌ی اصلی و \لر{PasswordChecker} ارائه دادیم استفاده می‌کنیم. از قابلیت ارسال \لر{Credential} پردازه در سوکت دامنه‌ی یونیکس استفاده میکنیم. به این صورت که برنامه‌ی اصلی هر بار که برنامه‌ی \لر{PasswordGetter} به آن وصل می‌شود با استفاده از شماره پردازه و شبه‌فایل‌سیستم \لر{proc} مسیر فایل اجرایی \لر{PasswordGetter} را به دست آورده و {\لر{Hash} آن را محاسبه می‌کند و در صورت معتبر بودن آن اجازه‌ی اتصال را می‌دهد. علاوه بر این برنامه‌ی اصلی چک می‌کند که فایل اجرایی برنامه‌ی \لر{PasswordGetter} توسط کاربر عادی مجوز نوشته شدن نداشته باشد تا \لر{Keylogger} نتواند پس از اجرای \لر{PasswordGetter} اصلی جایگزین شود.

\قسمت{مشکل رفتن گذرواژه روی دیسک سخت}

برای رفع این مشکل کافی است تا فراخوانی سیستمی \لر{mlock} استفاده کنیم. این فراخوانی سیستمی سبب می‌شود که تمامی صفحه‌ای\پانویس{page} که ادرس حافظه‌ی ورودی آن داده شده است قفل شود و هیچ‌وقت هنگام عمل \لر{Swap} بر روی دیسک سخت نرود.

\قسمت{مشکل \لر{Dumpable} بودن نرم‌افزار}
×
برای غیر فعال کردن \لر{Dumpable} بودن نرم‌افزار می‌توان از فراخوانی سیستمی \لر{setrlimit} استفاده کرد و مقدار فضای \لر{dump} را صفر قرار داد.


\قسمت{مشکل احراز هویت برنامه‌ها از طریق واسط برنامه‌نویسی}

برای اینکه بتوانیم برنامه‌های وصل شونده به واسط برنامه نویسی را احراز هویت کنیم از سوکت دامنه‌ی یونیکس استفاده میکنیم و به این صورت عمل می‌کنیم که از شبه‌فایل‌سیستم \لر{proc} آدرس فایل اجرایی و پس از آن \لر{Hash} آن را حساب می‌کنیم. 

حال اگر از قبل در پایگاه داده برنامه‌ای با این مشخصات وجود داشت که اجازه‌ی اتصال می‌دهیم. در غیر اینصورت اگر در پایگاه داده برنامه‌ای با آدرس فایل اجرایی یکسان وجود داشت ولی \لر{Hash} فایل‌ها متفاوت بود به این معنی است که احتمالاً نرم‌افزار وصل شونده به‌روز شده است. اما اگر برنامه‌ای نه با آدرس یکسان و نه با \لر{Hash} یکسان وجود داشت احتمالاً برنامه‌ای برای اولین بار به مدیر گذرواژه متصل شده است.

در دو حالت دوم باید مسیر اجرایی و \لر{Hash} را به کاربر نشان دهیم و از او تایید بگیریم که این برنامه اجازه‌ی وصل شدن دارد. برای این کار اگر از برنامه‌ای که روی \لر{X} اجرا می‌شود استفاده کنیم. \لر{Keylogger} می‌تواند با وصل شدن به \لر{X} دکمه‌های مربوط به تایید این عمل را به راحتی فشار دهد. پس باید دوباره به سراغ \لر{tty} برویم. برای این‌کار برنامه‌ی جدایی به نام APIMessageViewer می‌سازیم که وظیفه‌ی نشان دادن آدرس فایل اجرایی و \لر{Hash} برنامه‌ی جدید و تایید یا رد گرفتن از کاربر را به عهده دارد. تایید یا رد با دو عدد تصادفی که میسازیم و به کاربر نشان می‌دهیم صورت می‌گیرد. 

با توجه به اینکه یک نرم‌افزار مهاجم قابلیت نوشتن در \لر{tty} را دارد می‌تواند به راحتی آدرس فایل و هش را بازنویسی کند و کاربر را فریب دهد. برای رفع این مشکل این چهار قسمت پیغام یعنی :
\شروع{شمارش}
\فقره آدرس فایل اجرایی
\فقره \لر{Hash} فایل اجرایی
\فقره عدد مربوط به تایید کردن
\فقره عدد مربوط به رد کردن
\پایان{شمارش}

را در چهار جای تصادفی از صفحه می‌نویسیم تا نرم‌افزار مهاجم نتواند آدرس فایل و \لر{Hash} فایل اجرایی را جایگزین کند. برای مثال در یک کامپیوتر با اندازه‌ی مانیتور ۱۶.۴ اینچ که اندازه‌ی \لر{tty} آن برابر است با ۵۶x۲۰۰ احتمال درست نوشت مکان این آدرس‌ها تقریباً برابر است با ۰٫۰۰۰۰۰۰۰۰۸ که تقریباً غیرممکن به نظر می‌رسد.

در صورتی که کاربر این مورد را تایید کرد نرم‌افزار به پایگاه داده اضافه می‌شود و از دفعه‌ی بعد دیگر نیازی به تایید مجدد نیست.

